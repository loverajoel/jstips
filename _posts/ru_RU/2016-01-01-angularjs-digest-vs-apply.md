---
layout: post

title: AngularJs - `$digest` vs `$apply`
tip-number: 01
tip-username: loverajoel
tip-username-profile: https://github.com/loverajoel
tip-tldr: Количество и сложность JavaScript модулей и этапов сборки растет, а что насчет шаблонного кода в новых фреймворках?
tip-writer-support: https://www.coinbase.com/loverajoel

categories:
    - ru_RU
---

Одна из самых ценных особенностей AngularJS — двухстороннее связывание данных. Для того, чтобы это работало, AngularJS вычисляет изменения между моделью и представлением (view) с помощью циклов (`$digest`). Вам нужно понять этот концепт, чтобы иметь представление о том как работает фреймворк под капотом.

Angular оценивает изменения в каждом наблюдателе (watcher) всякий раз, когда срабатывает событие. Это называется `$digest` циклом.
Эта фаза одна из самых тяжелых по производительности и, если вам нужно вручную запустить новый цикл, вы должны выбрать оптимальный способ для конкретной ситуации.

### `$apply`

Этот встроенный метод позволяет явно запустить цикл `$digest`. Это значит, что все наблюдатели будут проверены и приложение запустит `$digest` цикл. После выполнения функции, переданной в качестве опционального аргумента, метод вызовет `$rootScope.$digest();`.

### `$digest`
В данном случае метод `$digest` запускает `$digest` цикл для текущей области видимости и всех вложенных. Области видимости уровнем выше не будут затронуты или проверены.

### Рекомендации
- Используйте `$apply` или `$digest` только когда браузерные DOM-события вызываются не из AngularJS.
- Передавайте функциональное выражение в качестве аргумента в `$apply`, этот метод имеет механизм ловли ошибок и позволяет интегрировать изменения в `$digest` цикле.

```javascript
$scope.$apply(() => {
	$scope.tip = 'Javascript Tip';
});
```

- Если вам нужно обновить только текущую область видимости и ее наследников, используйте `$digest`, и не допускайте новый digest-цикл для всего приложения. Выигрыш в производительности очевиден.
- `$apply()` — тяжелый процесс для компьютера и, при большом количестве связей, может стать причиной слабой производительности.
- Если вы используйте AngularJS версии >1.2.X, используйте внутренний метод `$evalAsync`, который оценит выражение в текущем или следующем цикле. Это может улучшить производительность приложения.
